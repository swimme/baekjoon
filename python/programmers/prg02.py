# #튜플 (자연수) - 시간초과 미해결
# # 1. 중복원소
# # 2. 원소 순서
# # 3. 유한개의 원소

# # <중복되는 원소가 없는> 튜플일때
# # {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}
# # == (a1,a2,a3,a4)
# # "집합의 원소순서는 무관" #"{{4,2,3},{3},{2,3,4,1},{2,3}}"

# # 입력: 집합이 담긴 문자열 s
# # "{{2},{2,1},{2,1,3},{2,1,3,4}}"
# # 출력: s가 표현하는 튜플을 배열에 담아
# # [2,1,3,4]

# # s의 원소 개수 = 튜플 원소개수
# # 이런 튜플의 원소는 중복x, 단 순서 중요 

s = "{{25},{25,1,3},{25,1},{25,1,3,4}}"
# a = s.replace("{","").replace("}","").split(",") 
# #['20', '20', '1', '3', '20', '1', '20', '1', '3', '4']

# # 원소는 알 수 있음 근데 순서? (n개면)
# # n번 나온게 1째
# # ...
# # 4번나온게 n-3
# # 3번나온게 n-2째
# # 2번나온게 n-1째
# # 1번나온게 n째
# # 집합의 총 원소수는 1+2+...n = (n+1)*n/2

# #중복제거 
# # 집합으로 변환
# b = set(a) #{'20','3', '4', '1'}

# answer = []
# while len(b)!=0:   
# 	for i in a:
# 		if a.count(i) == len(b):  #a에서 가장 많이중복되는 원소가 튜플의 첫번쨰원소
# 			answer.append(int(i))  #원소 int변환주의
# 			b.pop()

# print(answer)

# #test7~14 시간초과	

############################

# 각 {}로 나뉘어진 집합별로 나눈 다음에 집합 안의 숫자들을

# 배열에 순서를 지켜가면서 넣어주면 된다.

# 이 때, 각 집합을 길이 오름차순으로 나열한 다음 중복을 체크해주어야 한다.

def solution(s):
    answer = []
    s = s[2:-2]
    s = s.split("},{")
    s.sort(key = len)
    for i in s:
        ii = i.split(',')
        for j in ii:
            if int(j) not in answer:
                answer.append(int(j))
    return answerㄴ

print(solution(s))